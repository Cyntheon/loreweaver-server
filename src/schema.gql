# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Collection {
  _count: CollectionCount!
  author: User!
  authorId: UUID!
  contentList: [Content!]
  createdAt: DateTime!
  followTarget: FollowTarget!
  followTargetId: UUID!
  id: UUID!
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type CollectionCount {
  contentList: Int!
}

input CollectionCreateManyAuthorInput {
  followTargetId: UUID!
  title: String!
}

input CollectionCreateManyAuthorInputEnvelope {
  data: [CollectionCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input CollectionCreateNestedManyWithoutAuthorInput {
  connect: [CollectionWhereUniqueInput!]
  connectOrCreate: [CollectionCreateOrConnectWithoutAuthorInput!]
  create: [CollectionCreateWithoutAuthorInput!]
  createMany: CollectionCreateManyAuthorInputEnvelope
}

input CollectionCreateNestedOneWithoutFollowTargetInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutFollowTargetInput
  create: CollectionCreateWithoutFollowTargetInput
}

input CollectionCreateOrConnectWithoutAuthorInput {
  create: CollectionCreateWithoutAuthorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutFollowTargetInput {
  create: CollectionCreateWithoutFollowTargetInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateWithoutAuthorInput {
  contentList: ContentCreateNestedManyWithoutCollectionsInput
  title: String!
}

input CollectionCreateWithoutFollowTargetInput {
  author: UserCreateNestedOneWithoutCollectionsInput!
  contentList: ContentCreateNestedManyWithoutCollectionsInput
  title: String!
}

input CollectionListRelationFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

input CollectionOrderByRelationAggregateInput {
  _count: SortOrder
}

enum CollectionOrderByRelevanceFieldEnum {
  authorId
  followTargetId
  id
  slug
  title
}

input CollectionOrderByRelevanceInput {
  fields: [CollectionOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CollectionOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CollectionOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  contentList: ContentOrderByRelationAggregateInput
  createdAt: SortOrder
  followTarget: FollowTargetOrderByWithRelationAndSearchRelevanceInput
  followTargetId: SortOrder
  id: SortOrder
  slug: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

input CollectionScalarWhereInput {
  AND: [CollectionScalarWhereInput!]
  NOT: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  authorId: UuidFilter
  createdAt: DateTimeFilter
  followTargetId: UuidFilter
  id: UuidFilter
  slug: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input CollectionSlugAuthorIdCompoundUniqueInput {
  authorId: UUID!
  slug: String!
}

input CollectionUpdateManyMutationInput {
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateManyWithWhereWithoutAuthorInput {
  data: CollectionUpdateManyMutationInput!
  where: CollectionScalarWhereInput!
}

input CollectionUpdateManyWithoutAuthorNestedInput {
  connect: [CollectionWhereUniqueInput!]
  connectOrCreate: [CollectionCreateOrConnectWithoutAuthorInput!]
  create: [CollectionCreateWithoutAuthorInput!]
  createMany: CollectionCreateManyAuthorInputEnvelope
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CollectionUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CollectionUpdateOneWithoutFollowTargetNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutFollowTargetInput
  create: CollectionCreateWithoutFollowTargetInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionUpdateWithoutFollowTargetInput
  upsert: CollectionUpsertWithoutFollowTargetInput
}

input CollectionUpdateWithWhereUniqueWithoutAuthorInput {
  data: CollectionUpdateWithoutAuthorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpdateWithoutAuthorInput {
  contentList: ContentUpdateManyWithoutCollectionsNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutFollowTargetInput {
  author: UserUpdateOneRequiredWithoutCollectionsNestedInput
  contentList: ContentUpdateManyWithoutCollectionsNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpsertWithWhereUniqueWithoutAuthorInput {
  create: CollectionCreateWithoutAuthorInput!
  update: CollectionUpdateWithoutAuthorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutFollowTargetInput {
  create: CollectionCreateWithoutFollowTargetInput!
  update: CollectionUpdateWithoutFollowTargetInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  author: UserRelationFilter
  authorId: UuidFilter
  contentList: ContentListRelationFilter
  createdAt: DateTimeFilter
  followTarget: FollowTargetRelationFilter
  followTargetId: UuidFilter
  id: UuidFilter
  slug: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input CollectionWhereUniqueInput {
  followTargetId: UUID
  id: UUID
  slug_authorId: CollectionSlugAuthorIdCompoundUniqueInput
}

type Content {
  _count: ContentCount!
  collections: [Collection!]
  createdAt: DateTime!
  id: UUID!
  lore: Lore
  post: Post
  shortCode: Hexadecimal
  type: ContentType!
  updatedAt: DateTime!
}

type ContentCount {
  collections: Int!
}

input ContentCreateNestedManyWithoutCollectionsInput {
  connect: [ContentWhereUniqueInput!]
  connectOrCreate: [ContentCreateOrConnectWithoutCollectionsInput!]
  create: [ContentCreateWithoutCollectionsInput!]
}

input ContentCreateOrConnectWithoutCollectionsInput {
  create: ContentCreateWithoutCollectionsInput!
  where: ContentWhereUniqueInput!
}

input ContentCreateWithoutCollectionsInput {
  lore: LoreCreateNestedOneWithoutContentInput
  post: PostCreateNestedOneWithoutContentInput
  shortCode: Hexadecimal
  type: ContentType!
}

input ContentListRelationFilter {
  every: ContentWhereInput
  none: ContentWhereInput
  some: ContentWhereInput
}

input ContentOrderByRelationAggregateInput {
  _count: SortOrder
}

enum ContentOrderByRelevanceFieldEnum {
  id
  shortCode
}

input ContentOrderByRelevanceInput {
  fields: [ContentOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ContentOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ContentOrderByRelevanceInput
  collections: CollectionOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  lore: LoreOrderByWithRelationAndSearchRelevanceInput
  post: PostOrderByWithRelationAndSearchRelevanceInput
  shortCode: SortOrderInput
  type: SortOrder
  updatedAt: SortOrder
}

input ContentRelationFilter {
  is: ContentWhereInput
  isNot: ContentWhereInput
}

input ContentScalarWhereInput {
  AND: [ContentScalarWhereInput!]
  NOT: [ContentScalarWhereInput!]
  OR: [ContentScalarWhereInput!]
  createdAt: DateTimeFilter
  id: UuidFilter
  shortCode: StringNullableFilter
  type: EnumContentTypeFilter
  updatedAt: DateTimeFilter
}

enum ContentType {
  Lore
  Post
}

input ContentUpdateManyMutationInput {
  shortCode: NullableStringFieldUpdateOperationsInput
  type: EnumContentTypeFieldUpdateOperationsInput
}

input ContentUpdateManyWithWhereWithoutCollectionsInput {
  data: ContentUpdateManyMutationInput!
  where: ContentScalarWhereInput!
}

input ContentUpdateManyWithoutCollectionsNestedInput {
  connect: [ContentWhereUniqueInput!]
  connectOrCreate: [ContentCreateOrConnectWithoutCollectionsInput!]
  create: [ContentCreateWithoutCollectionsInput!]
  delete: [ContentWhereUniqueInput!]
  deleteMany: [ContentScalarWhereInput!]
  disconnect: [ContentWhereUniqueInput!]
  set: [ContentWhereUniqueInput!]
  update: [ContentUpdateWithWhereUniqueWithoutCollectionsInput!]
  updateMany: [ContentUpdateManyWithWhereWithoutCollectionsInput!]
  upsert: [ContentUpsertWithWhereUniqueWithoutCollectionsInput!]
}

input ContentUpdateWithWhereUniqueWithoutCollectionsInput {
  data: ContentUpdateWithoutCollectionsInput!
  where: ContentWhereUniqueInput!
}

input ContentUpdateWithoutCollectionsInput {
  lore: LoreUpdateOneWithoutContentNestedInput
  post: PostUpdateOneWithoutContentNestedInput
  shortCode: NullableStringFieldUpdateOperationsInput
  type: EnumContentTypeFieldUpdateOperationsInput
}

input ContentUpsertWithWhereUniqueWithoutCollectionsInput {
  create: ContentCreateWithoutCollectionsInput!
  update: ContentUpdateWithoutCollectionsInput!
  where: ContentWhereUniqueInput!
}

input ContentWhereInput {
  AND: [ContentWhereInput!]
  NOT: [ContentWhereInput!]
  OR: [ContentWhereInput!]
  collections: CollectionListRelationFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  lore: LoreRelationFilter
  post: PostRelationFilter
  shortCode: StringNullableFilter
  type: EnumContentTypeFilter
  updatedAt: DateTimeFilter
}

input ContentWhereUniqueInput {
  id: UUID
  shortCode: Hexadecimal
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

input EnumContentTypeFieldUpdateOperationsInput {
  set: ContentType
}

input EnumContentTypeFilter {
  equals: ContentType
  in: [ContentType!]
  not: NestedEnumContentTypeFilter
  notIn: [ContentType!]
}

input EnumFollowTargetTypeFieldUpdateOperationsInput {
  set: FollowTargetType
}

input EnumFollowTargetTypeFilter {
  equals: FollowTargetType
  in: [FollowTargetType!]
  not: NestedEnumFollowTargetTypeFilter
  notIn: [FollowTargetType!]
}

input EnumPostTypeFilter {
  equals: PostType
  in: [PostType!]
  not: NestedEnumPostTypeFilter
  notIn: [PostType!]
}

type Follow {
  followedAt: DateTime!
  followee: FollowTarget!
  followeeId: UUID!
  follower: User!
  followerId: UUID!
  id: UUID!
  isRequest: Boolean!
}

input FollowCreateManyFollowerInput {
  followeeId: UUID!
  isRequest: Boolean
}

input FollowCreateManyFollowerInputEnvelope {
  data: [FollowCreateManyFollowerInput!]!
  skipDuplicates: Boolean
}

input FollowCreateNestedManyWithoutFollowerInput {
  connect: [FollowWhereUniqueInput!]
  connectOrCreate: [FollowCreateOrConnectWithoutFollowerInput!]
  create: [FollowCreateWithoutFollowerInput!]
  createMany: FollowCreateManyFollowerInputEnvelope
}

input FollowCreateOrConnectWithoutFollowerInput {
  create: FollowCreateWithoutFollowerInput!
  where: FollowWhereUniqueInput!
}

input FollowCreateWithoutFollowerInput {
  followee: FollowTargetCreateNestedOneWithoutFollowedByInput!
  isRequest: Boolean
}

input FollowFollowerIdFolloweeIdCompoundUniqueInput {
  followeeId: UUID!
  followerId: UUID!
}

input FollowListRelationFilter {
  every: FollowWhereInput
  none: FollowWhereInput
  some: FollowWhereInput
}

input FollowOrderByRelationAggregateInput {
  _count: SortOrder
}

input FollowScalarWhereInput {
  AND: [FollowScalarWhereInput!]
  NOT: [FollowScalarWhereInput!]
  OR: [FollowScalarWhereInput!]
  followedAt: DateTimeFilter
  followeeId: UuidFilter
  followerId: UuidFilter
  id: UuidFilter
  isRequest: BoolFilter
}

type FollowTarget {
  _count: FollowTargetCount!
  collection: Collection
  followedBy: [Follow!]
  id: UUID!
  realm: Realm
  type: FollowTargetType!
  user: User
}

type FollowTargetCount {
  followedBy: Int!
}

input FollowTargetCreateNestedOneWithoutFollowedByInput {
  connect: FollowTargetWhereUniqueInput
  connectOrCreate: FollowTargetCreateOrConnectWithoutFollowedByInput
  create: FollowTargetCreateWithoutFollowedByInput
}

input FollowTargetCreateOrConnectWithoutFollowedByInput {
  create: FollowTargetCreateWithoutFollowedByInput!
  where: FollowTargetWhereUniqueInput!
}

input FollowTargetCreateWithoutFollowedByInput {
  collection: CollectionCreateNestedOneWithoutFollowTargetInput
  realm: RealmCreateNestedOneWithoutFollowTargetInput
  type: FollowTargetType!
  user: UserCreateNestedOneWithoutFollowTargetInput
}

enum FollowTargetOrderByRelevanceFieldEnum {
  id
}

input FollowTargetOrderByRelevanceInput {
  fields: [FollowTargetOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input FollowTargetOrderByWithRelationAndSearchRelevanceInput {
  _relevance: FollowTargetOrderByRelevanceInput
  collection: CollectionOrderByWithRelationAndSearchRelevanceInput
  followedBy: FollowOrderByRelationAggregateInput
  id: SortOrder
  realm: RealmOrderByWithRelationAndSearchRelevanceInput
  type: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
}

input FollowTargetRelationFilter {
  is: FollowTargetWhereInput
  isNot: FollowTargetWhereInput
}

enum FollowTargetType {
  Collection
  Realm
  User
}

input FollowTargetUpdateOneRequiredWithoutFollowedByNestedInput {
  connect: FollowTargetWhereUniqueInput
  connectOrCreate: FollowTargetCreateOrConnectWithoutFollowedByInput
  create: FollowTargetCreateWithoutFollowedByInput
  update: FollowTargetUpdateWithoutFollowedByInput
  upsert: FollowTargetUpsertWithoutFollowedByInput
}

input FollowTargetUpdateWithoutFollowedByInput {
  collection: CollectionUpdateOneWithoutFollowTargetNestedInput
  realm: RealmUpdateOneWithoutFollowTargetNestedInput
  type: EnumFollowTargetTypeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutFollowTargetNestedInput
}

input FollowTargetUpsertWithoutFollowedByInput {
  create: FollowTargetCreateWithoutFollowedByInput!
  update: FollowTargetUpdateWithoutFollowedByInput!
}

input FollowTargetWhereInput {
  AND: [FollowTargetWhereInput!]
  NOT: [FollowTargetWhereInput!]
  OR: [FollowTargetWhereInput!]
  collection: CollectionRelationFilter
  followedBy: FollowListRelationFilter
  id: UuidFilter
  realm: RealmRelationFilter
  type: EnumFollowTargetTypeFilter
  user: UserRelationFilter
}

input FollowTargetWhereUniqueInput {
  id: UUID
}

input FollowUpdateManyMutationInput {
  isRequest: BoolFieldUpdateOperationsInput
}

input FollowUpdateManyWithWhereWithoutFollowerInput {
  data: FollowUpdateManyMutationInput!
  where: FollowScalarWhereInput!
}

input FollowUpdateManyWithoutFollowerNestedInput {
  connect: [FollowWhereUniqueInput!]
  connectOrCreate: [FollowCreateOrConnectWithoutFollowerInput!]
  create: [FollowCreateWithoutFollowerInput!]
  createMany: FollowCreateManyFollowerInputEnvelope
  delete: [FollowWhereUniqueInput!]
  deleteMany: [FollowScalarWhereInput!]
  disconnect: [FollowWhereUniqueInput!]
  set: [FollowWhereUniqueInput!]
  update: [FollowUpdateWithWhereUniqueWithoutFollowerInput!]
  updateMany: [FollowUpdateManyWithWhereWithoutFollowerInput!]
  upsert: [FollowUpsertWithWhereUniqueWithoutFollowerInput!]
}

input FollowUpdateWithWhereUniqueWithoutFollowerInput {
  data: FollowUpdateWithoutFollowerInput!
  where: FollowWhereUniqueInput!
}

input FollowUpdateWithoutFollowerInput {
  followee: FollowTargetUpdateOneRequiredWithoutFollowedByNestedInput
  isRequest: BoolFieldUpdateOperationsInput
}

input FollowUpsertWithWhereUniqueWithoutFollowerInput {
  create: FollowCreateWithoutFollowerInput!
  update: FollowUpdateWithoutFollowerInput!
  where: FollowWhereUniqueInput!
}

input FollowWhereInput {
  AND: [FollowWhereInput!]
  NOT: [FollowWhereInput!]
  OR: [FollowWhereInput!]
  followedAt: DateTimeFilter
  followee: FollowTargetRelationFilter
  followeeId: UuidFilter
  follower: UserRelationFilter
  followerId: UuidFilter
  id: UuidFilter
  isRequest: BoolFilter
}

input FollowWhereUniqueInput {
  followerId_followeeId: FollowFollowerIdFolloweeIdCompoundUniqueInput
  id: UUID
}

"""
A field whose value is a hexadecimal: https://en.wikipedia.org/wiki/Hexadecimal.
"""
scalar Hexadecimal

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input LoginCredentialsEmailPasswordInput {
  email: String!
  password: String!
}

input LoginCredentialsUsernamePasswordInput {
  password: String!
  username: String!
}

type LoginResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type Lore {
  author: User!
  authorId: UUID!
  content: Content!
  contentId: UUID!
  contents: JSON!
  createdAt: DateTime!
  id: UUID!
  private: Boolean!
  realm: Realm!
  realmId: UUID!
  representsRealm: Realm
  slug: String!
  summary: String
  thumbnailUrl: URL
  title: String!
  updatedAt: DateTime!
}

input LoreCreateManyAuthorInput {
  contentId: UUID!
  contents: JSON!
  private: Boolean
  realmId: UUID!
  summary: String
  thumbnailUrl: URL
  title: String!
}

input LoreCreateManyAuthorInputEnvelope {
  data: [LoreCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input LoreCreateManyRealmInput {
  authorId: UUID!
  contentId: UUID!
  contents: JSON!
  private: Boolean
  summary: String
  thumbnailUrl: URL
  title: String!
}

input LoreCreateManyRealmInputEnvelope {
  data: [LoreCreateManyRealmInput!]!
  skipDuplicates: Boolean
}

input LoreCreateNestedManyWithoutAuthorInput {
  connect: [LoreWhereUniqueInput!]
  connectOrCreate: [LoreCreateOrConnectWithoutAuthorInput!]
  create: [LoreCreateWithoutAuthorInput!]
  createMany: LoreCreateManyAuthorInputEnvelope
}

input LoreCreateNestedManyWithoutRealmInput {
  connect: [LoreWhereUniqueInput!]
  connectOrCreate: [LoreCreateOrConnectWithoutRealmInput!]
  create: [LoreCreateWithoutRealmInput!]
  createMany: LoreCreateManyRealmInputEnvelope
}

input LoreCreateNestedOneWithoutContentInput {
  connect: LoreWhereUniqueInput
  connectOrCreate: LoreCreateOrConnectWithoutContentInput
  create: LoreCreateWithoutContentInput
}

input LoreCreateOrConnectWithoutAuthorInput {
  create: LoreCreateWithoutAuthorInput!
  where: LoreWhereUniqueInput!
}

input LoreCreateOrConnectWithoutContentInput {
  create: LoreCreateWithoutContentInput!
  where: LoreWhereUniqueInput!
}

input LoreCreateOrConnectWithoutRealmInput {
  create: LoreCreateWithoutRealmInput!
  where: LoreWhereUniqueInput!
}

input LoreCreateWithoutAuthorInput {
  contents: JSON!
  private: Boolean
  realm: RealmCreateNestedOneWithoutLoresInput!
  representsRealm: RealmCreateNestedOneWithoutRepresentationLoreInput
  summary: String
  thumbnailUrl: URL
  title: String!
}

input LoreCreateWithoutContentInput {
  author: UserCreateNestedOneWithoutLoresInput!
  contents: JSON!
  private: Boolean
  realm: RealmCreateNestedOneWithoutLoresInput!
  representsRealm: RealmCreateNestedOneWithoutRepresentationLoreInput
  summary: String
  thumbnailUrl: URL
  title: String!
}

input LoreCreateWithoutRealmInput {
  author: UserCreateNestedOneWithoutLoresInput!
  contents: JSON!
  private: Boolean
  representsRealm: RealmCreateNestedOneWithoutRepresentationLoreInput
  summary: String
  thumbnailUrl: URL
  title: String!
}

input LoreListRelationFilter {
  every: LoreWhereInput
  none: LoreWhereInput
  some: LoreWhereInput
}

input LoreOrderByRelationAggregateInput {
  _count: SortOrder
}

enum LoreOrderByRelevanceFieldEnum {
  authorId
  contentId
  id
  realmId
  slug
  summary
  thumbnailUrl
  title
}

input LoreOrderByRelevanceInput {
  fields: [LoreOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input LoreOrderByWithRelationAndSearchRelevanceInput {
  _relevance: LoreOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  content: ContentOrderByWithRelationAndSearchRelevanceInput
  contentId: SortOrder
  contents: SortOrder
  createdAt: SortOrder
  id: SortOrder
  private: SortOrder
  realm: RealmOrderByWithRelationAndSearchRelevanceInput
  realmId: SortOrder
  representsRealm: RealmOrderByWithRelationAndSearchRelevanceInput
  slug: SortOrder
  summary: SortOrderInput
  thumbnailUrl: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input LoreRelationFilter {
  is: LoreWhereInput
  isNot: LoreWhereInput
}

input LoreScalarWhereInput {
  AND: [LoreScalarWhereInput!]
  NOT: [LoreScalarWhereInput!]
  OR: [LoreScalarWhereInput!]
  authorId: UuidFilter
  contentId: UuidFilter
  contents: JsonFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  private: BoolFilter
  realmId: UuidFilter
  slug: StringFilter
  summary: StringNullableFilter
  thumbnailUrl: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input LoreSlugRealmIdCompoundUniqueInput {
  realmId: UUID!
  slug: String!
}

input LoreUpdateManyMutationInput {
  contents: JSON
  private: BoolFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
  thumbnailUrl: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input LoreUpdateManyWithWhereWithoutAuthorInput {
  data: LoreUpdateManyMutationInput!
  where: LoreScalarWhereInput!
}

input LoreUpdateManyWithWhereWithoutRealmInput {
  data: LoreUpdateManyMutationInput!
  where: LoreScalarWhereInput!
}

input LoreUpdateManyWithoutAuthorNestedInput {
  connect: [LoreWhereUniqueInput!]
  connectOrCreate: [LoreCreateOrConnectWithoutAuthorInput!]
  create: [LoreCreateWithoutAuthorInput!]
  createMany: LoreCreateManyAuthorInputEnvelope
  delete: [LoreWhereUniqueInput!]
  deleteMany: [LoreScalarWhereInput!]
  disconnect: [LoreWhereUniqueInput!]
  set: [LoreWhereUniqueInput!]
  update: [LoreUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [LoreUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [LoreUpsertWithWhereUniqueWithoutAuthorInput!]
}

input LoreUpdateManyWithoutRealmNestedInput {
  connect: [LoreWhereUniqueInput!]
  connectOrCreate: [LoreCreateOrConnectWithoutRealmInput!]
  create: [LoreCreateWithoutRealmInput!]
  createMany: LoreCreateManyRealmInputEnvelope
  delete: [LoreWhereUniqueInput!]
  deleteMany: [LoreScalarWhereInput!]
  disconnect: [LoreWhereUniqueInput!]
  set: [LoreWhereUniqueInput!]
  update: [LoreUpdateWithWhereUniqueWithoutRealmInput!]
  updateMany: [LoreUpdateManyWithWhereWithoutRealmInput!]
  upsert: [LoreUpsertWithWhereUniqueWithoutRealmInput!]
}

input LoreUpdateOneWithoutContentNestedInput {
  connect: LoreWhereUniqueInput
  connectOrCreate: LoreCreateOrConnectWithoutContentInput
  create: LoreCreateWithoutContentInput
  delete: Boolean
  disconnect: Boolean
  update: LoreUpdateWithoutContentInput
  upsert: LoreUpsertWithoutContentInput
}

input LoreUpdateWithWhereUniqueWithoutAuthorInput {
  data: LoreUpdateWithoutAuthorInput!
  where: LoreWhereUniqueInput!
}

input LoreUpdateWithWhereUniqueWithoutRealmInput {
  data: LoreUpdateWithoutRealmInput!
  where: LoreWhereUniqueInput!
}

input LoreUpdateWithoutAuthorInput {
  contents: JSON
  private: BoolFieldUpdateOperationsInput
  realm: RealmUpdateOneRequiredWithoutLoresNestedInput
  representsRealm: RealmUpdateOneWithoutRepresentationLoreNestedInput
  summary: NullableStringFieldUpdateOperationsInput
  thumbnailUrl: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input LoreUpdateWithoutContentInput {
  author: UserUpdateOneRequiredWithoutLoresNestedInput
  contents: JSON
  private: BoolFieldUpdateOperationsInput
  realm: RealmUpdateOneRequiredWithoutLoresNestedInput
  representsRealm: RealmUpdateOneWithoutRepresentationLoreNestedInput
  summary: NullableStringFieldUpdateOperationsInput
  thumbnailUrl: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input LoreUpdateWithoutRealmInput {
  author: UserUpdateOneRequiredWithoutLoresNestedInput
  contents: JSON
  private: BoolFieldUpdateOperationsInput
  representsRealm: RealmUpdateOneWithoutRepresentationLoreNestedInput
  summary: NullableStringFieldUpdateOperationsInput
  thumbnailUrl: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input LoreUpsertWithWhereUniqueWithoutAuthorInput {
  create: LoreCreateWithoutAuthorInput!
  update: LoreUpdateWithoutAuthorInput!
  where: LoreWhereUniqueInput!
}

input LoreUpsertWithWhereUniqueWithoutRealmInput {
  create: LoreCreateWithoutRealmInput!
  update: LoreUpdateWithoutRealmInput!
  where: LoreWhereUniqueInput!
}

input LoreUpsertWithoutContentInput {
  create: LoreCreateWithoutContentInput!
  update: LoreUpdateWithoutContentInput!
}

input LoreWhereInput {
  AND: [LoreWhereInput!]
  NOT: [LoreWhereInput!]
  OR: [LoreWhereInput!]
  author: UserRelationFilter
  authorId: UuidFilter
  content: ContentRelationFilter
  contentId: UuidFilter
  contents: JsonFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  private: BoolFilter
  realm: RealmRelationFilter
  realmId: UuidFilter
  representsRealm: RealmRelationFilter
  slug: StringFilter
  summary: StringNullableFilter
  thumbnailUrl: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input LoreWhereUniqueInput {
  contentId: UUID
  id: UUID
  slug_realmId: LoreSlugRealmIdCompoundUniqueInput
}

type Mutation {
  createUser(data: UserCreateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User!
  logInViaEmailPassword(credentials: LoginCredentialsEmailPasswordInput!): LoginResponse!
  logInViaUsernamePassword(credentials: LoginCredentialsUsernamePasswordInput!): LoginResponse!
  refreshAccessToken(refreshToken: String!): RefreshResponse!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumContentTypeFilter {
  equals: ContentType
  in: [ContentType!]
  not: NestedEnumContentTypeFilter
  notIn: [ContentType!]
}

input NestedEnumFollowTargetTypeFilter {
  equals: FollowTargetType
  in: [FollowTargetType!]
  not: NestedEnumFollowTargetTypeFilter
  notIn: [FollowTargetType!]
}

input NestedEnumPostTypeFilter {
  equals: PostType
  in: [PostType!]
  not: NestedEnumPostTypeFilter
  notIn: [PostType!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedUuidFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedUuidFilter
  notIn: [String!]
  search: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Post {
  author: User!
  authorId: UUID!
  content: Content!
  contentId: UUID!
  contents: JSON!
  createdAt: DateTime!
  id: UUID!
  type: PostType!
  updatedAt: DateTime!
}

input PostCreateManyAuthorInput {
  contentId: UUID!
  contents: JSON!
  type: PostType!
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateNestedOneWithoutContentInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutContentInput
  create: PostCreateWithoutContentInput
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutContentInput {
  create: PostCreateWithoutContentInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  contents: JSON!
  type: PostType!
}

input PostCreateWithoutContentInput {
  author: UserCreateNestedOneWithoutPostsInput!
  contents: JSON!
  type: PostType!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

enum PostOrderByRelevanceFieldEnum {
  authorId
  contentId
  id
}

input PostOrderByRelevanceInput {
  fields: [PostOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input PostOrderByWithRelationAndSearchRelevanceInput {
  _relevance: PostOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  content: ContentOrderByWithRelationAndSearchRelevanceInput
  contentId: SortOrder
  contents: SortOrder
  createdAt: SortOrder
  id: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  authorId: UuidFilter
  contentId: UuidFilter
  contents: JsonFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  type: EnumPostTypeFilter
  updatedAt: DateTimeFilter
}

enum PostType {
  Article
  Poll
  Text
}

input PostUpdateManyMutationInput {
  contents: JSON
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateOneWithoutContentNestedInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutContentInput
  create: PostCreateWithoutContentInput
  delete: Boolean
  disconnect: Boolean
  update: PostUpdateWithoutContentInput
  upsert: PostUpsertWithoutContentInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  contents: JSON
}

input PostUpdateWithoutContentInput {
  author: UserUpdateOneRequiredWithoutPostsNestedInput
  contents: JSON
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutContentInput {
  create: PostCreateWithoutContentInput!
  update: PostUpdateWithoutContentInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: UserRelationFilter
  authorId: UuidFilter
  content: ContentRelationFilter
  contentId: UuidFilter
  contents: JsonFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  type: EnumPostTypeFilter
  updatedAt: DateTimeFilter
}

input PostWhereUniqueInput {
  contentId: UUID
  id: UUID
}

type Query {
  me: User
  user(where: UserWhereUniqueInput!): User
  usernameTaken(username: String!): Boolean!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Realm {
  _count: RealmCount!
  author: User!
  authorId: UUID!
  createdAt: DateTime!
  followTarget: FollowTarget!
  followTargetId: UUID!
  id: UUID!
  lores: [Lore!]
  private: Boolean!
  representationLore: Lore!
  representationLoreId: String!
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type RealmCount {
  lores: Int!
}

input RealmCreateManyAuthorInput {
  followTargetId: UUID!
  private: Boolean
  representationLoreId: String!
  title: String!
}

input RealmCreateManyAuthorInputEnvelope {
  data: [RealmCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input RealmCreateNestedManyWithoutAuthorInput {
  connect: [RealmWhereUniqueInput!]
  connectOrCreate: [RealmCreateOrConnectWithoutAuthorInput!]
  create: [RealmCreateWithoutAuthorInput!]
  createMany: RealmCreateManyAuthorInputEnvelope
}

input RealmCreateNestedOneWithoutFollowTargetInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutFollowTargetInput
  create: RealmCreateWithoutFollowTargetInput
}

input RealmCreateNestedOneWithoutLoresInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutLoresInput
  create: RealmCreateWithoutLoresInput
}

input RealmCreateNestedOneWithoutRepresentationLoreInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutRepresentationLoreInput
  create: RealmCreateWithoutRepresentationLoreInput
}

input RealmCreateOrConnectWithoutAuthorInput {
  create: RealmCreateWithoutAuthorInput!
  where: RealmWhereUniqueInput!
}

input RealmCreateOrConnectWithoutFollowTargetInput {
  create: RealmCreateWithoutFollowTargetInput!
  where: RealmWhereUniqueInput!
}

input RealmCreateOrConnectWithoutLoresInput {
  create: RealmCreateWithoutLoresInput!
  where: RealmWhereUniqueInput!
}

input RealmCreateOrConnectWithoutRepresentationLoreInput {
  create: RealmCreateWithoutRepresentationLoreInput!
  where: RealmWhereUniqueInput!
}

input RealmCreateWithoutAuthorInput {
  lores: LoreCreateNestedManyWithoutRealmInput
  private: Boolean
  title: String!
}

input RealmCreateWithoutFollowTargetInput {
  author: UserCreateNestedOneWithoutRealmsInput!
  lores: LoreCreateNestedManyWithoutRealmInput
  private: Boolean
  title: String!
}

input RealmCreateWithoutLoresInput {
  author: UserCreateNestedOneWithoutRealmsInput!
  private: Boolean
  title: String!
}

input RealmCreateWithoutRepresentationLoreInput {
  author: UserCreateNestedOneWithoutRealmsInput!
  lores: LoreCreateNestedManyWithoutRealmInput
  private: Boolean
  title: String!
}

input RealmListRelationFilter {
  every: RealmWhereInput
  none: RealmWhereInput
  some: RealmWhereInput
}

input RealmOrderByRelationAggregateInput {
  _count: SortOrder
}

enum RealmOrderByRelevanceFieldEnum {
  authorId
  followTargetId
  id
  representationLoreId
  slug
  title
}

input RealmOrderByRelevanceInput {
  fields: [RealmOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input RealmOrderByWithRelationAndSearchRelevanceInput {
  _relevance: RealmOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  createdAt: SortOrder
  followTarget: FollowTargetOrderByWithRelationAndSearchRelevanceInput
  followTargetId: SortOrder
  id: SortOrder
  lores: LoreOrderByRelationAggregateInput
  private: SortOrder
  representationLore: LoreOrderByWithRelationAndSearchRelevanceInput
  representationLoreId: SortOrder
  slug: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input RealmRelationFilter {
  is: RealmWhereInput
  isNot: RealmWhereInput
}

input RealmScalarWhereInput {
  AND: [RealmScalarWhereInput!]
  NOT: [RealmScalarWhereInput!]
  OR: [RealmScalarWhereInput!]
  authorId: UuidFilter
  createdAt: DateTimeFilter
  followTargetId: UuidFilter
  id: UuidFilter
  private: BoolFilter
  representationLoreId: UuidFilter
  slug: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input RealmSlugAuthorIdCompoundUniqueInput {
  authorId: UUID!
  slug: String!
}

input RealmUpdateManyMutationInput {
  private: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input RealmUpdateManyWithWhereWithoutAuthorInput {
  data: RealmUpdateManyMutationInput!
  where: RealmScalarWhereInput!
}

input RealmUpdateManyWithoutAuthorNestedInput {
  connect: [RealmWhereUniqueInput!]
  connectOrCreate: [RealmCreateOrConnectWithoutAuthorInput!]
  create: [RealmCreateWithoutAuthorInput!]
  createMany: RealmCreateManyAuthorInputEnvelope
  delete: [RealmWhereUniqueInput!]
  deleteMany: [RealmScalarWhereInput!]
  disconnect: [RealmWhereUniqueInput!]
  set: [RealmWhereUniqueInput!]
  update: [RealmUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [RealmUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [RealmUpsertWithWhereUniqueWithoutAuthorInput!]
}

input RealmUpdateOneRequiredWithoutLoresNestedInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutLoresInput
  create: RealmCreateWithoutLoresInput
  update: RealmUpdateWithoutLoresInput
  upsert: RealmUpsertWithoutLoresInput
}

input RealmUpdateOneWithoutFollowTargetNestedInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutFollowTargetInput
  create: RealmCreateWithoutFollowTargetInput
  delete: Boolean
  disconnect: Boolean
  update: RealmUpdateWithoutFollowTargetInput
  upsert: RealmUpsertWithoutFollowTargetInput
}

input RealmUpdateOneWithoutRepresentationLoreNestedInput {
  connect: RealmWhereUniqueInput
  connectOrCreate: RealmCreateOrConnectWithoutRepresentationLoreInput
  create: RealmCreateWithoutRepresentationLoreInput
  delete: Boolean
  disconnect: Boolean
  update: RealmUpdateWithoutRepresentationLoreInput
  upsert: RealmUpsertWithoutRepresentationLoreInput
}

input RealmUpdateWithWhereUniqueWithoutAuthorInput {
  data: RealmUpdateWithoutAuthorInput!
  where: RealmWhereUniqueInput!
}

input RealmUpdateWithoutAuthorInput {
  lores: LoreUpdateManyWithoutRealmNestedInput
  private: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input RealmUpdateWithoutFollowTargetInput {
  author: UserUpdateOneRequiredWithoutRealmsNestedInput
  lores: LoreUpdateManyWithoutRealmNestedInput
  private: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input RealmUpdateWithoutLoresInput {
  author: UserUpdateOneRequiredWithoutRealmsNestedInput
  private: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input RealmUpdateWithoutRepresentationLoreInput {
  author: UserUpdateOneRequiredWithoutRealmsNestedInput
  lores: LoreUpdateManyWithoutRealmNestedInput
  private: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input RealmUpsertWithWhereUniqueWithoutAuthorInput {
  create: RealmCreateWithoutAuthorInput!
  update: RealmUpdateWithoutAuthorInput!
  where: RealmWhereUniqueInput!
}

input RealmUpsertWithoutFollowTargetInput {
  create: RealmCreateWithoutFollowTargetInput!
  update: RealmUpdateWithoutFollowTargetInput!
}

input RealmUpsertWithoutLoresInput {
  create: RealmCreateWithoutLoresInput!
  update: RealmUpdateWithoutLoresInput!
}

input RealmUpsertWithoutRepresentationLoreInput {
  create: RealmCreateWithoutRepresentationLoreInput!
  update: RealmUpdateWithoutRepresentationLoreInput!
}

input RealmWhereInput {
  AND: [RealmWhereInput!]
  NOT: [RealmWhereInput!]
  OR: [RealmWhereInput!]
  author: UserRelationFilter
  authorId: UuidFilter
  createdAt: DateTimeFilter
  followTarget: FollowTargetRelationFilter
  followTargetId: UuidFilter
  id: UuidFilter
  lores: LoreListRelationFilter
  private: BoolFilter
  representationLore: LoreRelationFilter
  representationLoreId: UuidFilter
  slug: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input RealmWhereUniqueInput {
  followTargetId: UUID
  id: UUID
  representationLoreId: String
  slug_authorId: RealmSlugAuthorIdCompoundUniqueInput
}

type RefreshResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

type User {
  _count: UserCount!
  collections: [Collection!]
  followTarget: FollowTarget!
  followTargetId: UUID!
  following: [Follow!]
  id: UUID!
  joinedAt: DateTime!
  lores: [Lore!]
  nickname: String
  posts: [Post!]
  profile: UserProfile
  realms: [Realm!]
  username: String!
}

type UserAuthCountAggregate {
  _all: Int!
  createdAt: Int!
  data: Int!
  id: Int!
  type: Int!
  updatedAt: Int!
  userId: Int!
}

type UserAuthMaxAggregate {
  createdAt: DateTime
  id: UUID
  type: UserAuthType
  updatedAt: DateTime
  userId: UUID
}

type UserAuthMinAggregate {
  createdAt: DateTime
  id: UUID
  type: UserAuthType
  updatedAt: DateTime
  userId: UUID
}

enum UserAuthType {
  EmailPassword
  Google
  UsernamePassword
}

type UserCount {
  authData: Int!
  collections: Int!
  following: Int!
  lores: Int!
  posts: Int!
  realms: Int!
}

type UserCountAggregate {
  _all: Int!
  followTargetId: Int!
  id: Int!
  joinedAt: Int!
  nickname: Int!
  username: Int!
}

input UserCreateInput {
  collections: CollectionCreateNestedManyWithoutAuthorInput
  email: EmailAddress!
  following: FollowCreateNestedManyWithoutFollowerInput
  lores: LoreCreateNestedManyWithoutAuthorInput
  nickname: String
  password: String!
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: UserProfileCreateNestedOneWithoutUserInput
  realms: RealmCreateNestedManyWithoutAuthorInput
  username: String!
}

input UserCreateNestedOneWithoutCollectionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCollectionsInput
  create: UserCreateWithoutCollectionsInput
}

input UserCreateNestedOneWithoutFollowTargetInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFollowTargetInput
  create: UserCreateWithoutFollowTargetInput
}

input UserCreateNestedOneWithoutLoresInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoresInput
  create: UserCreateWithoutLoresInput
}

input UserCreateNestedOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
}

input UserCreateNestedOneWithoutRealmsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRealmsInput
  create: UserCreateWithoutRealmsInput
}

input UserCreateOrConnectWithoutCollectionsInput {
  create: UserCreateWithoutCollectionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFollowTargetInput {
  create: UserCreateWithoutFollowTargetInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLoresInput {
  create: UserCreateWithoutLoresInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRealmsInput {
  create: UserCreateWithoutRealmsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCollectionsInput {
  following: FollowCreateNestedManyWithoutFollowerInput
  lores: LoreCreateNestedManyWithoutAuthorInput
  nickname: String
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: UserProfileCreateNestedOneWithoutUserInput
  realms: RealmCreateNestedManyWithoutAuthorInput
  username: String!
}

input UserCreateWithoutFollowTargetInput {
  collections: CollectionCreateNestedManyWithoutAuthorInput
  following: FollowCreateNestedManyWithoutFollowerInput
  lores: LoreCreateNestedManyWithoutAuthorInput
  nickname: String
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: UserProfileCreateNestedOneWithoutUserInput
  realms: RealmCreateNestedManyWithoutAuthorInput
  username: String!
}

input UserCreateWithoutLoresInput {
  collections: CollectionCreateNestedManyWithoutAuthorInput
  following: FollowCreateNestedManyWithoutFollowerInput
  nickname: String
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: UserProfileCreateNestedOneWithoutUserInput
  realms: RealmCreateNestedManyWithoutAuthorInput
  username: String!
}

input UserCreateWithoutPostsInput {
  collections: CollectionCreateNestedManyWithoutAuthorInput
  following: FollowCreateNestedManyWithoutFollowerInput
  lores: LoreCreateNestedManyWithoutAuthorInput
  nickname: String
  profile: UserProfileCreateNestedOneWithoutUserInput
  realms: RealmCreateNestedManyWithoutAuthorInput
  username: String!
}

input UserCreateWithoutRealmsInput {
  collections: CollectionCreateNestedManyWithoutAuthorInput
  following: FollowCreateNestedManyWithoutFollowerInput
  lores: LoreCreateNestedManyWithoutAuthorInput
  nickname: String
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
}

type UserMaxAggregate {
  followTargetId: UUID
  id: UUID
  joinedAt: DateTime
  nickname: String
  username: String
}

type UserMinAggregate {
  followTargetId: UUID
  id: UUID
  joinedAt: DateTime
  nickname: String
  username: String
}

enum UserOrderByRelevanceFieldEnum {
  followTargetId
  id
  nickname
  username
}

input UserOrderByRelevanceInput {
  fields: [UserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserOrderByRelevanceInput
  collections: CollectionOrderByRelationAggregateInput
  followTarget: FollowTargetOrderByWithRelationAndSearchRelevanceInput
  followTargetId: SortOrder
  following: FollowOrderByRelationAggregateInput
  id: SortOrder
  joinedAt: SortOrder
  lores: LoreOrderByRelationAggregateInput
  nickname: SortOrderInput
  posts: PostOrderByRelationAggregateInput
  profile: UserProfileOrderByWithRelationAndSearchRelevanceInput
  realms: RealmOrderByRelationAggregateInput
  username: SortOrder
}

type UserProfile {
  avatarUrl: URL
  bannerUrl: URL
  bio: String
  createdAt: DateTime!
  id: UUID!
  location: String
  private: Boolean!
  pronouns: String
  updatedAt: DateTime!
  user: User!
  userId: UUID!
  website: String
}

input UserProfileCreateNestedOneWithoutUserInput {
  connect: UserProfileWhereUniqueInput
  connectOrCreate: UserProfileCreateOrConnectWithoutUserInput
  create: UserProfileCreateWithoutUserInput
}

input UserProfileCreateOrConnectWithoutUserInput {
  create: UserProfileCreateWithoutUserInput!
  where: UserProfileWhereUniqueInput!
}

input UserProfileCreateWithoutUserInput {
  avatarUrl: URL
  bannerUrl: URL
  bio: String
  location: String
  private: Boolean
  pronouns: String
  website: String
}

enum UserProfileOrderByRelevanceFieldEnum {
  avatarUrl
  bannerUrl
  bio
  id
  location
  pronouns
  userId
  website
}

input UserProfileOrderByRelevanceInput {
  fields: [UserProfileOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserProfileOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserProfileOrderByRelevanceInput
  avatarUrl: SortOrderInput
  bannerUrl: SortOrderInput
  bio: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  location: SortOrderInput
  private: SortOrder
  pronouns: SortOrderInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
  website: SortOrderInput
}

input UserProfileRelationFilter {
  is: UserProfileWhereInput
  isNot: UserProfileWhereInput
}

input UserProfileUpdateOneWithoutUserNestedInput {
  connect: UserProfileWhereUniqueInput
  connectOrCreate: UserProfileCreateOrConnectWithoutUserInput
  create: UserProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: UserProfileUpdateWithoutUserInput
  upsert: UserProfileUpsertWithoutUserInput
}

input UserProfileUpdateWithoutUserInput {
  avatarUrl: NullableStringFieldUpdateOperationsInput
  bannerUrl: NullableStringFieldUpdateOperationsInput
  bio: NullableStringFieldUpdateOperationsInput
  location: NullableStringFieldUpdateOperationsInput
  private: BoolFieldUpdateOperationsInput
  pronouns: NullableStringFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
}

input UserProfileUpsertWithoutUserInput {
  create: UserProfileCreateWithoutUserInput!
  update: UserProfileUpdateWithoutUserInput!
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  avatarUrl: StringNullableFilter
  bannerUrl: StringNullableFilter
  bio: StringNullableFilter
  createdAt: DateTimeFilter
  id: UuidFilter
  location: StringNullableFilter
  private: BoolFilter
  pronouns: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: UuidFilter
  website: StringNullableFilter
}

input UserProfileWhereUniqueInput {
  id: UUID
  userId: UUID
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  followTargetId
  id
  joinedAt
  nickname
  username
}

input UserUpdateInput {
  collections: CollectionUpdateManyWithoutAuthorNestedInput
  following: FollowUpdateManyWithoutFollowerNestedInput
  lores: LoreUpdateManyWithoutAuthorNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  realms: RealmUpdateManyWithoutAuthorNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCollectionsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCollectionsInput
  create: UserCreateWithoutCollectionsInput
  update: UserUpdateWithoutCollectionsInput
  upsert: UserUpsertWithoutCollectionsInput
}

input UserUpdateOneRequiredWithoutLoresNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoresInput
  create: UserCreateWithoutLoresInput
  update: UserUpdateWithoutLoresInput
  upsert: UserUpsertWithoutLoresInput
}

input UserUpdateOneRequiredWithoutPostsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateOneRequiredWithoutRealmsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRealmsInput
  create: UserCreateWithoutRealmsInput
  update: UserUpdateWithoutRealmsInput
  upsert: UserUpsertWithoutRealmsInput
}

input UserUpdateOneWithoutFollowTargetNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFollowTargetInput
  create: UserCreateWithoutFollowTargetInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFollowTargetInput
  upsert: UserUpsertWithoutFollowTargetInput
}

input UserUpdateWithoutCollectionsInput {
  following: FollowUpdateManyWithoutFollowerNestedInput
  lores: LoreUpdateManyWithoutAuthorNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  realms: RealmUpdateManyWithoutAuthorNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutFollowTargetInput {
  collections: CollectionUpdateManyWithoutAuthorNestedInput
  following: FollowUpdateManyWithoutFollowerNestedInput
  lores: LoreUpdateManyWithoutAuthorNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  realms: RealmUpdateManyWithoutAuthorNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutLoresInput {
  collections: CollectionUpdateManyWithoutAuthorNestedInput
  following: FollowUpdateManyWithoutFollowerNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  realms: RealmUpdateManyWithoutAuthorNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutPostsInput {
  collections: CollectionUpdateManyWithoutAuthorNestedInput
  following: FollowUpdateManyWithoutFollowerNestedInput
  lores: LoreUpdateManyWithoutAuthorNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  realms: RealmUpdateManyWithoutAuthorNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutRealmsInput {
  collections: CollectionUpdateManyWithoutAuthorNestedInput
  following: FollowUpdateManyWithoutFollowerNestedInput
  lores: LoreUpdateManyWithoutAuthorNestedInput
  nickname: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  profile: UserProfileUpdateOneWithoutUserNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutCollectionsInput {
  create: UserCreateWithoutCollectionsInput!
  update: UserUpdateWithoutCollectionsInput!
}

input UserUpsertWithoutFollowTargetInput {
  create: UserCreateWithoutFollowTargetInput!
  update: UserUpdateWithoutFollowTargetInput!
}

input UserUpsertWithoutLoresInput {
  create: UserCreateWithoutLoresInput!
  update: UserUpdateWithoutLoresInput!
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsInput!
}

input UserUpsertWithoutRealmsInput {
  create: UserCreateWithoutRealmsInput!
  update: UserUpdateWithoutRealmsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  collections: CollectionListRelationFilter
  followTarget: FollowTargetRelationFilter
  followTargetId: UuidFilter
  following: FollowListRelationFilter
  id: UuidFilter
  joinedAt: DateTimeFilter
  lores: LoreListRelationFilter
  nickname: StringNullableFilter
  posts: PostListRelationFilter
  profile: UserProfileRelationFilter
  realms: RealmListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  followTargetId: UUID
  id: UUID
  username: String
}

input UuidFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedUuidFilter
  notIn: [String!]
  search: String
}